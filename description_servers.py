import os
import sys
import subprocess
import paramiko
import pandas as pd
from concurrent.futures import ThreadPoolExecutor, as_completed
from datetime import datetime
from colorama import init, Fore, Style
from openpyxl import Workbook
from openpyxl.styles import PatternFill, Font, Alignment
from openpyxl.utils.dataframe import dataframe_to_rows
from openpyxl.worksheet.table import Table, TableStyleInfo
import logging
from queue import Queue  # Потокобезопасные коллекции

# Инициализация colorama
init(autoreset=True)

# Настройка логирования
logging.basicConfig(filename="server_scan.log", 
                    level=logging.DEBUG, 
                    format="%(asctime)s - %(levelname)s - %(message)s")

# Счетчики для статистики
total_servers = 0
successful_checks = 0
failed_checks = 0
ping_failures = 0

# Функция для получения среднего пинга в Windows
def get_ping_to_istanbul(ip):
    global ping_failures
    try:
        ping_output = subprocess.check_output(f"ping -n 4 {ip}", shell=True).decode()
        for line in ping_output.splitlines():
            if "Average" in line:
                avg_ping = line.split()[-1]
                return avg_ping
        return "N/A"
    except subprocess.CalledProcessError as e:
        logging.error(f"Ошибка при попытке получить пинг до {ip}: {e}")
        ping_failures += 1
        return "N/A"
    except Exception as e:
        logging.error(f"Общая ошибка при получении пинга до {ip}: {e}")
        ping_failures += 1
        return "N/A"

# Определение типа сервера (VPS или Dedicated)
def detect_server_type(client):
    try:
        stdin, stdout, stderr = client.exec_command("systemd-detect-virt")
        virtualization_type = stdout.read().decode().strip().lower()
        if virtualization_type == "none":
            return "Dedicated"
        else:
            return "VPS"
    except Exception as e:
        logging.error(f"Ошибка определения типа сервера: {e}")
        return "Unknown"

# Функция для выполнения команды на удалённом сервере
def execute_command(client, command, fallback_command=None):
    try:
        stdin, stdout, stderr = client.exec_command(command)
        result = stdout.read().decode().strip()
        if result or not fallback_command:
            return result
        stdin, stdout, stderr = client.exec_command(fallback_command)
        return stdout.read().decode().strip()
    except Exception as e:
        logging.error(f"Ошибка выполнения команды {command}: {e}")
        return "N/A"

# Основной код для сбора данных с серверов
def get_server_data(ip, user, password):
    global successful_checks, failed_checks
    client = paramiko.SSHClient()
    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    try:
        logging.info(f"Подключение к серверу {ip}...")
        client.connect(ip, username=user, password=password, timeout=10)
        
        # Сбор информации о CPU
        cpu_model = execute_command(client, "lscpu | grep 'Model name' | awk -F ': ' '{print $2}'", 
                                            "cat /proc/cpuinfo | grep 'model name' | head -1 | awk -F ': ' '{print $2}'")
        cpu_freq = execute_command(client, "lscpu | grep 'CPU MHz' | awk -F ': ' '{print $2}'", 
                                            "cat /proc/cpuinfo | grep 'cpu MHz' | head -1 | awk -F ': ' '{print $2}'")
        cpu_cores = execute_command(client, "lscpu | grep '^CPU(s):' | awk -F ': ' '{print $2}'", 
                                            "cat /proc/cpuinfo | grep 'processor' | wc -l")

        # Получение информации о памяти
        stdin, stdout, stderr = client.exec_command("free -m")
        free_output = stdout.read().decode().strip().splitlines()
        mem_data = free_output[1].split()
        ram_total, ram_used, ram_free = f"{mem_data[1]} MB", f"{mem_data[2]} MB", f"{mem_data[3]} MB"

        # Получение информации о диске
        stdin, stdout, stderr = client.exec_command("df -h /")
        disk_data = stdout.read().decode().splitlines()[1].split()
        disk_total, disk_used, disk_free = disk_data[1], disk_data[2], disk_data[3]

        # Получение среднего пинга
        ping_to_istanbul = get_ping_to_istanbul(ip)

        # Определение типа сервера (VPS или Dedicated)
        server_type = detect_server_type(client)
        
        successful_checks += 1
        return {
            "IP": ip,
            "CPU Model": cpu_model,
            "CPU Frequency": f"{cpu_freq} MHz",
            "CPU Cores": int(cpu_cores),
            "RAM Total": ram_total,
            "RAM Used": ram_used,
            "RAM Free": ram_free,
            "Disk Total": disk_total,
            "Disk Used": disk_used,
            "Disk Free": disk_free,
            "Ping to Istanbul": ping_to_istanbul,
            "Server Type": server_type
        }
    except Exception as e:
        logging.error(f"Ошибка подключения к {ip}: {e}")
        failed_checks += 1
        return None
    finally:
        client.close()  # Закрытие SSH соединения в любом случае

# Функция для классификации серверов
def classify_server(server_data):
    try:
        cpu_cores = server_data.get("CPU Cores", 0)
        ram_free_str = server_data.get("RAM Free", "0 MB")
        ram_free = int(ram_free_str.split()[0])
        if cpu_cores >= 4 and ram_free >= 2000:
            return "Strong"
        else:
            return "Weak"
    except Exception as e:
        logging.error(f"Ошибка классификации сервера {server_data.get('IP', 'Unknown')}: {e}")
        return "Weak"

# Запись статистики в лог-файлы
def log_statistics():
    try:
        with open("successful_checks.txt", "w", encoding='utf-8') as success_log, \
             open("failed_checks.txt", "w", encoding='utf-8') as fail_log, \
             open("ping_failures.txt", "w", encoding='utf-8') as ping_log:
            
            success_log.write(f"Успешно проверенные серверы: {successful_checks}\n")
            fail_log.write(f"Неудачные проверки серверов: {failed_checks}\n")
            ping_log.write(f"Серверы без пинга: {ping_failures}\n")

        logging.info(f"\nСтатистика:\n- Успешно проверено: {successful_checks}\n- Не удалось проверить: {failed_checks}\n- Серверов без пинга: {ping_failures}")
    except UnicodeEncodeError as e:
        logging.error(f"Ошибка кодировки при записи статистики: {e}")
    except Exception as e:
        logging.error(f"Ошибка записи статистики: {e}")

# Обновление Excel-файла
def update_excel(strong_servers, weak_servers, output_file):
    try:
        # Собираем данные из очередей
        strong_servers_list = list(strong_servers.queue)
        weak_servers_list = list(weak_servers.queue)

        if not strong_servers_list and not weak_servers_list:
            logging.warning("Нет данных для записи в Excel.")
            return

        all_servers = sorted(strong_servers_list + weak_servers_list, 
                             key=lambda x: (-x['CPU Cores'], -int(x['RAM Free'].split()[0])))

        # Создаем DataFrame
        df = pd.DataFrame(all_servers)
        
        # Создаем книгу и добавляем стили
        wb = Workbook()
        ws = wb.active
        ws.title = "Server Data"

        # Добавляем данные из DataFrame в рабочий лист
        for r in dataframe_to_rows(df, index=False, header=True):
            ws.append(r)
        
        # Создаем таблицу и применяем стили
        table = Table(displayName="ServerTable", ref=ws.dimensions)
        style = TableStyleInfo(name="TableStyleMedium9", showRowStripes=True)
        table.tableStyleInfo = style
        ws.add_table(table)

        # Применяем цветное форматирование к заголовкам
        header_font = Font(bold=True, color="FFFFFF")
        header_fill = PatternFill(start_color="4F81BD", end_color="4F81BD", fill_type="solid")

        for cell in ws[1]:
            cell.font = header_font
            cell.fill = header_fill
            cell.alignment = Alignment(horizontal="center")

        # Сохранение в Excel
        wb.save(output_file)
        logging.info(f"Данные сохранены в {output_file}")
    except Exception as e:
        logging.error(f"Ошибка при обновлении Excel-файла: {e}")

# Обработка одного сервера
def process_server(ip, user, password, checked_ips, strong_servers, weak_servers):
    if ip in checked_ips.queue:
        logging.warning(f"Сервер {ip} уже проверен, пропускаем.")
        return None
    
    try:
        server_data = get_server_data(ip, user, password)
        if server_data:
            category = classify_server(server_data)
            if category == "Strong":
                strong_servers.put(server_data)
            else:
                weak_servers.put(server_data)
            return ip
        else:
            logging.warning(f"Не удалось получить данные для {ip}")
    except Exception as e:
        logging.error(f"Ошибка при обработке сервера {ip}: {e}")
    return None

def main():
    global total_servers
    output_file = "Server_Classification.xlsx"
    strong_servers, weak_servers, checked_ips = Queue(), Queue(), Queue()

    if os.path.exists(output_file):
        try:
            existing_data = pd.read_excel(output_file, sheet_name=None)
            strong_servers = Queue([existing_data.get("Strong Servers", pd.DataFrame()).to_dict('records')])
            weak_servers = Queue([existing_data.get("Weak Servers", pd.DataFrame()).to_dict('records')])
            checked_ips = Queue([item['IP'] for item in strong_servers.queue + weak_servers.queue])
        except Exception as e:
            logging.error(f"Ошибка чтения существующего Excel-файла: {e}")

    try:
        with open('servers.txt', encoding='utf-8') as f:
            servers = [line.strip().split(':') for line in f if line.strip()]
            total_servers = len(servers)
    except Exception as e:
        logging.error(f"Ошибка чтения файла servers.txt: {e}")
        servers = []

    max_workers = min(32, os.cpu_count() + 4)  # Определяем оптимальное число потоков

    try:
        with ThreadPoolExecutor(max_workers=max_workers) as executor:  # Параллельная обработка
            futures = {executor.submit(process_server, ip, user, password, checked_ips, strong_servers, weak_servers): ip 
                       for ip, user, password in servers}

            for future in as_completed(futures):
                try:
                    ip = future.result()
                    if ip:
                        checked_ips.put(ip)
                except Exception as e:
                    logging.error(f"Ошибка при обработке сервера {futures[future]}: {e}")

        # Сохраняем все данные в Excel после завершения всех проверок
        update_excel(strong_servers, weak_servers, output_file)

    except Exception as e:
        logging.error(f"Скрипт завершен с ошибкой: {e}")
    
    log_statistics()  # Записываем статистику
    logging.info("Проверка завершена.")
    print(Fore.CYAN + "Проверка завершена.")

if __name__ == "__main__":
    main()